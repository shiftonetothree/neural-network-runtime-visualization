<html>

<head>
    <style>
        .screen {
            width: 100px;
            height: 60px;
            width: 60px;
        }

        .screen_table {
            display: flex;
        }

        .matrix_table {
            display: flex;
        }

        .matrix {
            width: 33px;
            height: 15px;
        }

        table {
            border-collapse: collapse;
            border: 2px solid rgb(140 140 140);
            font-family: sans-serif;
            font-size: 0.8rem;
            letter-spacing: 1px;
        }

        caption {
            caption-side: bottom;
            padding: 10px;
            font-weight: bold;
        }

        thead,
        tfoot {
            background-color: rgb(228 240 245);
        }

        th,
        td {
            border: 1px solid rgb(160 160 160);
            /* padding: 8px 10px; */
            /* min-height: 30px; */
        }
        

        td:last-of-type {
            text-align: center;
        }

        tbody>tr:nth-of-type(even) {
            background-color: rgb(237 238 242);
        }

        tfoot th {
            text-align: right;
        }

        tfoot td {
            font-weight: bold;
        }

        .caculator_cell{
            width: 80px;
            max-width: 80px;
            min-width: 80px;
            overflow: hidden;
            height: 15px;
            border: 1px solid rgb(160 160 160);
            text-align: center;
        }

        .arrow{
            background-color: red;
            position: absolute;
            height: 6px;
            transform-origin: left center;
        }
        .arrow_top{
            position: absolute;
            top: -3px;
            right: 0;
            transform: rotate(45deg);
            width: 12px;
            height: 12px;
            background-color: red;;
            transform-origin: center;
        }
        .matrix_container{
            display: inline-flex;
            align-items: top;
        }
        .matrix_container table{
            display: inline-flex;
        }

        .layer{
            background-color: rgba(0, 183, 255, 0.2);
        }
        .weight{
            background-color: rgba(0, 183, 255, 0.5);
        }
        .delta{
            background-color: rgba(0, 94, 255, 0.8);
        }
        .label{
            background-color: rgba(0, 183, 255, 0.8);
        }
    </style>
</head>

<body v-scope v-once>
    <div><label>每个计算步骤等待的时间(毫秒)：</label>0<input id="animationDelay" type="range" min="0" max="1000" step="1" value="1000" onchange="changeAnimationDelay(event)">1000<label id="progress"></label></div>
    <table v-for="(caculatorIds, index) in caculatorIdMatrix">
        <tr>
            <td class="caculator_cell">公式{{index+1}}：</td>
            <td v-for="id in caculatorIds" :id="id" class="caculator_cell"></td>
        </tr>
    </table>
    <div class="matrix_container">
        <table class="matrix_table">
            <tr v-for="(id,index) in layer0IdMatrix">
                <td v-if="index == 0" :colspan="maxColumnCount" :rowspan="maxRowCount"></td>
                <td>|-|</td>
                <td><input :id="id" class="matrix layer" type="text" min="0" max="1" step="0.01" :value="Math.random() - 0.5"></td>
            </tr>
            <tr><td>--</td></tr>
            <tr v-for="(row,index) in weight0_1IdMatrix">
                <td v-for="cell in row"><input :id="cell" class="matrix weight" type="text" min="0" max="1" step="0.01" :value="Math.random() - 0.5"></td>
                <td>|-|</td>
                <td><input :id="'layer1_'+index+'_0'" class="matrix layer" type="text" min="0" max="1" step="0.01" :value="Math.random() - 0.5"></td>
                <td>|-|</td>
                <td><input :id="'delta1_'+index+'_0'" class="matrix delta" type="text" min="0" max="1" step="0.01"></td>
            </tr>
            <tr><td>--</td></tr>
            <tr v-for="(row,index) in weight1_2IdMatrix">
                <td v-if="index == 0" :colspan="maxColumnCount - row.length" :rowspan="weight1_2IdMatrix.length"></td>
                <td v-for="cell in row"><input :id="cell" class="matrix weight" type="text" min="0" max="1" step="0.01" :value="Math.random() - 0.5"></td>
                <td>|-|</td>
                <td><input :id="'layer2_'+index+'_0'" class="matrix layer" type="text" min="0" max="1" step="0.01" :value="Math.random() - 0.5"></td>
                <td>|-|</td>
                <td><input :id="'delta2_'+index+'_0'" class="matrix delta" type="text" min="0" max="1" step="0.01"></td>
            </tr>
            <tr><td>--</td></tr>
            <tr v-for="(row,index) in weight2_3IdMatrix">
                <td v-if="index == 0" :colspan="maxColumnCount - row.length" :rowspan="weight2_3IdMatrix.length"></td>
                <td v-for="cell in row"><input :id="cell" class="matrix weight" type="text" min="0" max="1" step="0.01" :value="Math.random() - 0.5"></td>
                <td>|-|</td>
                <td><input :id="'layer3_'+index+'_0'" class="matrix layer" type="text" min="0" max="1" step="0.01" :value="Math.random() - 0.5"></td>
                <td>|-|</td>
                <td><input :id="'delta3_'+index+'_0'" class="matrix delta" type="text" min="0" max="1" step="0.01"></td>
                <td><input :id="'label_'+index+'_0'" class="matrix label" type="text" min="0" max="1" step="0.01"></td>
            </tr>
            <table class="screen_table">
                <tr v-for="(_,row) in 5">
                    <td v-for="(_,column) in 3"><input :id="'screen_'+row+'_'+column" class="screen" type="checkbox"></td>
                </tr>
            </table>
        </table>
    </div>
    <div v-for="arrowId in arrowIds" :id="arrowId" class="arrow">
        <div class="arrow_top"></div>
    </div>
</body>
<script src="petite-vue.iife.js"></script>
<script>

const learnRate = 0.2;
let animationDelay = 1000;
function changeAnimationDelay(e){
    animationDelay = e.target.value;
}
const dataSet = [
    {
        data: [
            [1,1,1],
            [1,0,1],
            [1,0,1],
            [1,0,1],
            [1,1,1],
        ],
        lable: '0',
        labelMatrix: [
            [1],[0],[0],[0],[0],[0],[0],[0],[0],[0]
        ]
    },
    {
        data: [
            [0,1,0],
            [1,1,0],
            [0,1,0],
            [0,1,0],
            [1,1,1],
        ],
        lable: '1',
        labelMatrix: [
            [0],[1],[0],[0],[0],[0],[0],[0],[0],[0]
        ]
    },
    {
        data: [
            [1,1,1],
            [0,0,1],
            [1,1,1],
            [1,0,0],
            [1,1,1],
        ],
        lable: '2',
        labelMatrix: [
            [0],[0],[1],[0],[0],[0],[0],[0],[0],[0]
        ]
    },
    {
        data: [
            [1,1,1],
            [0,0,1],
            [1,1,1],
            [0,0,1],
            [1,1,1],
        ],
        lable: '3',
        labelMatrix: [
            [0],[0],[0],[1],[0],[0],[0],[0],[0],[0]
        ]
    },
    {
        data: [
            [1,0,1],
            [1,0,1],
            [1,1,1],
            [0,0,1],
            [0,0,1],
        ],
        lable: '4',
        labelMatrix: [
            [0],[0],[0],[0],[1],[0],[0],[0],[0],[0]
        ]
    },
    {
        data: [
            [1,1,1],
            [1,0,0],
            [1,1,1],
            [0,0,1],
            [1,1,1],
        ],
        lable: '5',
        labelMatrix: [
            [0],[0],[0],[0],[0],[1],[0],[0],[0],[0]
        ]
    },
    {
        data: [
            [1,1,1],
            [1,0,0],
            [1,1,1],
            [1,0,1],
            [1,1,1],
        ],
        lable: '6',
        labelMatrix: [
            [0],[0],[0],[0],[0],[0],[1],[0],[0],[0]
        ]
    },
    {
        data: [
            [1,1,1],
            [0,0,1],
            [0,0,1],
            [0,0,1],
            [0,0,1],
        ],
        lable: '7',
        labelMatrix: [
            [0],[0],[0],[0],[0],[0],[0],[1],[0],[0]
        ]
    },
    {
        data: [
            [1,1,1],
            [1,0,1],
            [1,1,1],
            [1,0,1],
            [1,1,1],
        ],
        lable: '8',
        labelMatrix: [
            [0],[0],[0],[0],[0],[0],[0],[0],[1],[0]
        ]
    },
    {
        data: [
            [1,1,1],
            [1,0,1],
            [1,1,1],
            [0,0,1],
            [1,1,1],
        ],
        lable: '9',
        labelMatrix: [
            [0],[0],[0],[0],[0],[0],[0],[0],[0],[1]
        ]
    }
];

const layer0IdMatrix = [
        ["layer0_0_0"],
        ["layer0_1_0"],
        ["layer0_2_0"],
        ["layer0_3_0"],
        ["layer0_4_0"],
        ["layer0_5_0"],
        ["layer0_6_0"],
        ["layer0_7_0"],
        ["layer0_8_0"],
        ["layer0_9_0"],
        ["layer0_10_0"],
        ["layer0_11_0"],
        ["layer0_12_0"],
        ["layer0_13_0"],
        ["layer0_14_0"]
    ]

    const weight0_1IdMatrix = [
        ["weight0_1_0_0", "weight0_1_0_1", "weight0_1_0_2", "weight0_1_0_3", "weight0_1_0_4", "weight0_1_0_5", "weight0_1_0_6", "weight0_1_0_7", "weight0_1_0_8", "weight0_1_0_9", "weight0_1_0_10", "weight0_1_0_11", "weight0_1_0_12", "weight0_1_0_13", "weight0_1_0_14"],
        ["weight0_1_1_0", "weight0_1_1_1", "weight0_1_1_2", "weight0_1_1_3", "weight0_1_1_4", "weight0_1_1_5", "weight0_1_1_6", "weight0_1_1_7", "weight0_1_1_8", "weight0_1_1_9", "weight0_1_1_10", "weight0_1_1_11", "weight0_1_1_12", "weight0_1_1_13", "weight0_1_1_14"],
        ["weight0_1_2_0", "weight0_1_2_1", "weight0_1_2_2", "weight0_1_2_3", "weight0_1_2_4", "weight0_1_2_5", "weight0_1_2_6", "weight0_1_2_7", "weight0_1_2_8", "weight0_1_2_9", "weight0_1_2_10", "weight0_1_2_11", "weight0_1_2_12", "weight0_1_2_13", "weight0_1_2_14"],
        ["weight0_1_3_0", "weight0_1_3_1", "weight0_1_3_2", "weight0_1_3_3", "weight0_1_3_4", "weight0_1_3_5", "weight0_1_3_6", "weight0_1_3_7", "weight0_1_3_8", "weight0_1_3_9", "weight0_1_3_10", "weight0_1_3_11", "weight0_1_3_12", "weight0_1_3_13", "weight0_1_3_14"],
        ["weight0_1_4_0", "weight0_1_4_1", "weight0_1_4_2", "weight0_1_4_3", "weight0_1_4_4", "weight0_1_4_5", "weight0_1_4_6", "weight0_1_4_7", "weight0_1_4_8", "weight0_1_4_9", "weight0_1_4_10", "weight0_1_4_11", "weight0_1_4_12", "weight0_1_4_13", "weight0_1_4_14"],
        ["weight0_1_5_0", "weight0_1_5_1", "weight0_1_5_2", "weight0_1_5_3", "weight0_1_5_4", "weight0_1_5_5", "weight0_1_5_6", "weight0_1_5_7", "weight0_1_5_8", "weight0_1_5_9", "weight0_1_5_10", "weight0_1_5_11", "weight0_1_5_12", "weight0_1_5_13", "weight0_1_5_14"],
        ["weight0_1_6_0", "weight0_1_6_1", "weight0_1_6_2", "weight0_1_6_3", "weight0_1_6_4", "weight0_1_6_5", "weight0_1_6_6", "weight0_1_6_7", "weight0_1_6_8", "weight0_1_6_9", "weight0_1_6_10", "weight0_1_6_11", "weight0_1_6_12", "weight0_1_6_13", "weight0_1_6_14"],
        ["weight0_1_7_0", "weight0_1_7_1", "weight0_1_7_2", "weight0_1_7_3", "weight0_1_7_4", "weight0_1_7_5", "weight0_1_7_6", "weight0_1_7_7", "weight0_1_7_8", "weight0_1_7_9", "weight0_1_7_10", "weight0_1_7_11", "weight0_1_7_12", "weight0_1_7_13", "weight0_1_7_14"],
        ["weight0_1_8_0", "weight0_1_8_1", "weight0_1_8_2", "weight0_1_8_3", "weight0_1_8_4", "weight0_1_8_5", "weight0_1_8_6", "weight0_1_8_7", "weight0_1_8_8", "weight0_1_8_9", "weight0_1_8_10", "weight0_1_8_11", "weight0_1_8_12", "weight0_1_8_13", "weight0_1_8_14"],
        ["weight0_1_9_0", "weight0_1_9_1", "weight0_1_9_2", "weight0_1_9_3", "weight0_1_9_4", "weight0_1_9_5", "weight0_1_9_6", "weight0_1_9_7", "weight0_1_9_8", "weight0_1_9_9", "weight0_1_9_10", "weight0_1_9_11", "weight0_1_9_12", "weight0_1_9_13", "weight0_1_9_14"]
    ]


    const layer1IdMatrix = [
        ["layer1_0_0"],
        ["layer1_1_0"],
        ["layer1_2_0"],
        ["layer1_3_0"],
        ["layer1_4_0"],
        ["layer1_5_0"],
        ["layer1_6_0"],
        ["layer1_7_0"],
        ["layer1_8_0"],
        ["layer1_9_0"]
    ]

    const weight1_2IdMatrix = [
        ["weight1_2_0_0", "weight1_2_0_1", "weight1_2_0_2", "weight1_2_0_3", "weight1_2_0_4", "weight1_2_0_5", "weight1_2_0_6", "weight1_2_0_7", "weight1_2_0_8", "weight1_2_0_9"],
        ["weight1_2_1_0", "weight1_2_1_1", "weight1_2_1_2", "weight1_2_1_3", "weight1_2_1_4", "weight1_2_1_5", "weight1_2_1_6", "weight1_2_1_7", "weight1_2_1_8", "weight1_2_1_9"],
        ["weight1_2_2_0", "weight1_2_2_1", "weight1_2_2_2", "weight1_2_2_3", "weight1_2_2_4", "weight1_2_2_5", "weight1_2_2_6", "weight1_2_2_7", "weight1_2_2_8", "weight1_2_2_9"],
        ["weight1_2_3_0", "weight1_2_3_1", "weight1_2_3_2", "weight1_2_3_3", "weight1_2_3_4", "weight1_2_3_5", "weight1_2_3_6", "weight1_2_3_7", "weight1_2_3_8", "weight1_2_3_9"],
        ["weight1_2_4_0", "weight1_2_4_1", "weight1_2_4_2", "weight1_2_4_3", "weight1_2_4_4", "weight1_2_4_5", "weight1_2_4_6", "weight1_2_4_7", "weight1_2_4_8", "weight1_2_4_9"],
        ["weight1_2_5_0", "weight1_2_5_1", "weight1_2_5_2", "weight1_2_5_3", "weight1_2_5_4", "weight1_2_5_5", "weight1_2_5_6", "weight1_2_5_7", "weight1_2_5_8", "weight1_2_5_9"],
        ["weight1_2_6_0", "weight1_2_6_1", "weight1_2_6_2", "weight1_2_6_3", "weight1_2_6_4", "weight1_2_6_5", "weight1_2_6_6", "weight1_2_6_7", "weight1_2_6_8", "weight1_2_6_9"],
        ["weight1_2_7_0", "weight1_2_7_1", "weight1_2_7_2", "weight1_2_7_3", "weight1_2_7_4", "weight1_2_7_5", "weight1_2_7_6", "weight1_2_7_7", "weight1_2_7_8", "weight1_2_7_9"],
        ["weight1_2_8_0", "weight1_2_8_1", "weight1_2_8_2", "weight1_2_8_3", "weight1_2_8 4", "weight1_2_8_5", "weight1_2_8_6", "weight1_2_8_7", "weight1_2_8_8", "weight1_2_8_9"],
        ["weight1_2_9_0", "weight1_2_9_1", "weight1_2_9_2", "weight1_2_9_3", "weight1_2_9 4", "weight1_2_9_5", "weight1_2_9_6", "weight1_2_9_7", "weight1_2_9_8", "weight1_2_9_9"]
    ]

    const layer2IdMatrix = [
        ["layer2_0_0"],
        ["layer2_1_0"],
        ["layer2_2_0"],
        ["layer2_3_0"],
        ["layer2_4_0"],
        ["layer2_5_0"],
        ["layer2_6_0"],
        ["layer2_7_0"],
        ["layer2_8_0"],
        ["layer2_9_0"]
    ]

    const weight2_3IdMatrix = [
        ["weight2_3_0_0", "weight2_3_0_1", "weight2_3_0_2", "weight2_3_0_3", "weight2_3_0_4", "weight2_3_0_5", "weight2_3_0_6", "weight2_3_0_7", "weight2_3_0_8", "weight2_3_0_9"],
        ["weight2_3_1_0", "weight2_3_1_1", "weight2_3_1_2", "weight2_3_1_3", "weight2_3_1_4", "weight2_3_1_5", "weight2_3_1_6", "weight2_3_1_7", "weight2_3_1_8", "weight2_3_1_9"],
        ["weight2_3_2_0", "weight2_3_2_1", "weight2_3_2_2", "weight2_3_2_3", "weight2_3_2_4", "weight2_3_2_5", "weight2_3_2_6", "weight2_3_2_7", "weight2_3_2_8", "weight2_3_2_9"],
        ["weight2_3_3_0", "weight2_3_3_1", "weight2_3_3_2", "weight2_3_3_3", "weight2_3_3_4", "weight2_3_3_5", "weight2_3_3_6", "weight2_3_3_7", "weight2_3_3_8", "weight2_3_3_9"],
        ["weight2_3_4_0", "weight2_3_4_1", "weight2_3_4_2", "weight2_3_4_3", "weight2_3_4_4", "weight2_3_4_5", "weight2_3_4_6", "weight2_3_4_7", "weight2_3_4_8", "weight2_3_4_9"],
        ["weight2_3_5_0", "weight2_3_5_1", "weight2_3_5_2", "weight2_3_5_3", "weight2_3_5_4", "weight2_3_5_5", "weight2_3_5_6", "weight2_3_5_7", "weight2_3_5_8", "weight2_3_5_9"],
        ["weight2_3_6_0", "weight2_3_6_1", "weight2_3_6_2", "weight2_3_6_3", "weight2_3_6_4", "weight2_3_6_5", "weight2_3_6_6", "weight2_3_6_7", "weight2_3_6_8", "weight2_3_6_9"],
        ["weight2_3_7_0", "weight2_3_7_1", "weight2_3_7_2", "weight2_3_7_3", "weight2_3_7_4", "weight2_3_7_5", "weight2_3_7_6", "weight2_3_7_7", "weight2_3_7_8", "weight2_3_7_9"],
        ["weight2_3_8_0", "weight2_3_8_1", "weight2_3_8_2", "weight2_3_8_3", "weight2_3_8_4", "weight2_3_8_5", "weight2_3_8_6", "weight2_3_8_7", "weight2_3_8_8", "weight2_3_8_9"],
        ["weight2_3_9_0", "weight2_3_9_1", "weight2_3_9_2", "weight2_3_9_3", "weight2_3_9 4", "weight2_3_9_5", "weight2_3_9_6", "weight2_3_9_7", "weight2_3_9_8", "weight2_3_9_9"]
    ]

    const layer3IdMatrix = [
        ["layer3_0_0"],
        ["layer3_1_0"],
        ["layer3_2_0"],
        ["layer3_3_0"],
        ["layer3_4_0"],
        ["layer3_5_0"],
        ["layer3_6_0"],
        ["layer3_7_0"],
        ["layer3_8_0"],
        ["layer3_9_0"]
    ]

    const labelIdMatrix = [
        ["label_0_0"],
        ["label_1_0"],
        ["label_2_0"],
        ["label_3_0"],
        ["label_4_0"],
        ["label_5_0"],
        ["label_6_0"],
        ["label_7_0"],
        ["label_8_0"],
        ["label_9_0"]
    ]

    const delta1IdMatrix = [
        ["delta1_0_0"],
        ["delta1_1_0"],
        ["delta1_2_0"],
        ["delta1_3_0"],
        ["delta1_4_0"],
        ["delta1_5_0"],
        ["delta1_6_0"],
        ["delta1_7_0"],
        ["delta1_8_0"],
        ["delta1_9_0"]
    ]

    const delta2IdMatrix = [
        ["delta2_0_0"],
        ["delta2_1_0"],
        ["delta2_2_0"],
        ["delta2_3_0"],
        ["delta2_4_0"],
        ["delta2_5_0"],
        ["delta2_6_0"],
        ["delta2_7_0"],
        ["delta2_8_0"],
        ["delta2_9_0"]
    ]

    const delta3IdMatrix = [
        ["delta3_0_0"],
        ["delta3_1_0"],
        ["delta3_2_0"],
        ["delta3_3_0"],
        ["delta3_4_0"],
        ["delta3_5_0"],
        ["delta3_6_0"],
        ["delta3_7_0"],
        ["delta3_8_0"],
        ["delta3_9_0"]
    ]

    const caculatorIdMatrix = [
        ["caculator0_0", "caculator0_1", "caculator0_2", "caculator0_3", "caculator0_4", "caculator0_5", "caculator0_6", "caculator0_7", "caculator0_8", "caculator0_9", "caculator0_10", "caculator0_11", "caculator0_12", "caculator0_13", "caculator0_14"],
        ["caculator1_0", "caculator1_1", "caculator1_2", "caculator1_3", "caculator1_4", "caculator1_5", "caculator1_6", "caculator1_7", "caculator1_8", "caculator1_9", "caculator1_10", "caculator1_11", "caculator1_12", "caculator1_13", "caculator1_14"],
        ["caculator2_0", "caculator2_1", "caculator2_2", "caculator2_3", "caculator2_4", "caculator2_5", "caculator2_6", "caculator2_7", "caculator2_8", "caculator2_9", "caculator2_10", "caculator2_11", "caculator2_12", "caculator2_13", "caculator2_14"],
        ["caculator3_0", "caculator3_1", "caculator3_2", "caculator3_3", "caculator3_4", "caculator3_5", "caculator3_6", "caculator3_7", "caculator3_8", "caculator3_9", "caculator3_10", "caculator3_11", "caculator3_12", "caculator3_13", "caculator3_14"],
        ["caculator4_0", "caculator4_1", "caculator4_2", "caculator4_3", "caculator4_4", "caculator4_5", "caculator4_6", "caculator4_7", "caculator4_8", "caculator4_9", "caculator4_10", "caculator4_11", "caculator4_12", "caculator4_13", "caculator4_14"],
    ]

    const arrowIds = [
        "arrow0",
        "arrow1",
        "arrow2",
        "arrow3",
        "arrow4",
        "arrow5",
        "arrow6",
        "arrow7",
    ]
    const maxColumnCount = Math.max(
        weight0_1IdMatrix[0].length, weight1_2IdMatrix[0].length, weight2_3IdMatrix[0].length
    );
    const maxRowCount = Math.max(
        layer0IdMatrix.length, layer1IdMatrix.length, layer2IdMatrix.length, layer3IdMatrix.length
    );

    function getValue(id) {
        // console.log("getValue id", id)
        // if (id == null) {
        //     debugger;
        // }
        const element = document.getElementById(id);
        if(element.type == "checkbox"){
            return parseFloat(element.checked);
        }else{
            return parseFloat(element.value);
        }
        
    }
    function setValue(id, value) {
        // if(id == "weight0_1_0_0"){
        //     debugger
        // }
        console.log("setValue id", id)
        const element = document.getElementById(id);
        if (element.className.indexOf("caculator_cell")>=0){
            element.innerText = value;
        }else if(element.type == "checkbox"){
            return element.checked = value;
        }else{
            return element.value = value;
        }
        
    }

    function setCaculator(row, cells){
        for(let i = 0; i < cells.length; i++){
            const cell = cells[i];
            const id = "caculator" + row + "_" + (i);
            setValue(id, cell);
        }
    }

    function setProgress(progress){
        document.getElementById("progress").innerHTML = progress;
    }

    function getAbsolutePosition(element) {
        let x = 0, y = 0;
        let current = element;
        while (current) {
            x += current.offsetLeft;
            y += current.offsetTop;
            current = current.offsetParent;
        }
        return { x: x + 10, y: y + 10 };
    }

    /** 绘制一个从一个元素到另一个元素的直线 */
    function drawArrow(arrowId, color ,elementIdA,elementIdB){
        const elementA = document.getElementById(elementIdA);
        const elementB = document.getElementById(elementIdB);
        const {x: x1, y: y1} = getAbsolutePosition(elementA);
        const {x: x2, y: y2} = getAbsolutePosition(elementB);
        const arrow = document.getElementById(arrowId);
        arrow.style.width = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)) + "px";
        arrow.style.left = x1 + "px";
        arrow.style.top = y1 + "px";
        arrow.style.transform = "rotate(" + Math.atan2((y2 - y1), x2 - x1) + "rad)";
        arrow.style.backgroundColor = color;
        arrow.style.display = "block";
        arrow.children.item(0).style.backgroundColor = color;
    }

    function clearArrow(arrowId){
        for(let i = 0;i<arrowIds.length;i++){
            const arrowId = arrowIds[i];
            const arrow = document.getElementById(arrowId);
            arrow.style.display = "none";
        }
    }


    async function playMatrixCrossStepAnimation(matrixIdA,matrixIdB,resultMatrixId){
        const result = getValue(resultMatrixId) + getValue(matrixIdA) * getValue(matrixIdB)
        setCaculator(0,[getValue(resultMatrixId),"+",getValue(matrixIdA),"x",getValue(matrixIdB),"=",result]);
        drawArrow(arrowIds[0],"red",matrixIdA, caculatorIdMatrix[0][2]);
        drawArrow(arrowIds[1],"red",matrixIdB, caculatorIdMatrix[0][4]);
        
        await sleep(animationDelay);
    }

    async function playActivationFunction‌Animation(resultMatrixId){
        const result = 1 / (1 + Math.exp(getValue(resultMatrixId)))
        setCaculator(1,["1 / (1 + " , "Math.exp(",getValue(resultMatrixId),") =",result]);
        drawArrow(arrowIds[2],"red",caculatorIdMatrix[0][6], caculatorIdMatrix[1][2]);
        drawArrow(arrowIds[3],"green",caculatorIdMatrix[1][4], resultMatrixId)
        await sleep(animationDelay);
    }

    async function playOutputDeltaFunction‌Animation(outputId, labelId, outputDeltaId){
        const resultValue = getValue(outputId);
        const labelValue = getValue(labelId);
        const outputDeltaValue = 0.2 * (resultValue - labelValue);
        setCaculator(2,["0.2 * (",resultValue,"-",labelValue,") =",outputDeltaValue]);
        drawArrow(arrowIds[5],"red",outputId, caculatorIdMatrix[2][1]);
        drawArrow(arrowIds[6],"red",labelId, caculatorIdMatrix[2][3]);
        drawArrow(arrowIds[7],"green",caculatorIdMatrix[2][5], outputDeltaId);
        await sleep(animationDelay);
    }

    async function playBackpropagation‌WeightAnimation(weightId, deltaId, upperLayerId,layerId){
        const weightValue = getValue(weightId);
        const deltaValue = getValue(deltaId);
        const layerValue = getValue(layerId);
        const upperLayerValue = getValue(upperLayerId);
        const newWeightValue = weightValue +  (learnRate * -1) * deltaValue * upperLayerValue * layerValue * (1 - layerValue);
        setCaculator(3,[weightValue,"+ ("+learnRate," * -1) *",deltaValue,"*",upperLayerValue,"*",layerValue,"* (1 -",layerValue,") =", newWeightValue]);
        drawArrow(arrowIds[0],"red",weightId, caculatorIdMatrix[3][0]);
        drawArrow(arrowIds[1],"red",deltaId, caculatorIdMatrix[3][3]);
        drawArrow(arrowIds[2],"red",upperLayerId, caculatorIdMatrix[3][5]);
        drawArrow(arrowIds[3],"red",layerId, caculatorIdMatrix[3][7]);
        drawArrow(arrowIds[4],"red",layerId, caculatorIdMatrix[3][9]);
        drawArrow(arrowIds[5],"green",caculatorIdMatrix[3][11], weightId);
        await sleep(animationDelay);
    }

    async function playBackpropagation‌LayerAnimation(weightId,deltaId,upperLayerDeltaId){
        const weightValue = getValue(weightId);
        const deltaValue = getValue(deltaId);
        const upperLayerDelta = getValue(upperLayerDeltaId);
        const newUpperLayerDelta = upperLayerDelta + weightValue * deltaValue;
        setCaculator(4,[upperLayerDelta,"+",weightValue,"*",deltaValue,"=",newUpperLayerDelta]);
        drawArrow(arrowIds[0],"red", upperLayerDeltaId, caculatorIdMatrix[4][0]);
        drawArrow(arrowIds[1],"red", weightId, caculatorIdMatrix[4][2]);
        drawArrow(arrowIds[2],"red", deltaId, caculatorIdMatrix[4][4]);
        drawArrow(arrowIds[3],"green", caculatorIdMatrix[4][6], upperLayerDeltaId);
        await sleep(animationDelay);
    }

    async function playPutTrainDataToMatrix(i,j,layerId){
        drawArrow(arrowIds[0],"green", "screen_"+i+"_"+j, layerId);
        await sleep(animationDelay)
    }
    
    /** 激活函数和矩阵乘法的复合Sigmod(AB) */
    async function sigmodMatrixCross(matrixIdsA, matrixIdsB, resultMatrixIds) {
        for (let i = 0; i < matrixIdsA.length; i++) {
            // 左取行
            const matrixIdsARow = matrixIdsA[i];
            for(let j=0;j< matrixIdsB[0].length;j++){
                // 右取列
                const matrixIdsBColumn = getColumn(matrixIdsB, j);
                const resultMatrixId = resultMatrixIds[i][j];
                // if(resultMatrixId == "layer3_0_0"){
                //     debugger
                // }
                setValue(resultMatrixId, 0);
                for(let m = 0; m < matrixIdsARow.length; m++){
                    // 相乘再相加
                    const matrixIdA = matrixIdsARow[m];
                    const matrixIdB = matrixIdsBColumn[m];
                    await playMatrixCrossStepAnimation(matrixIdA, matrixIdB, resultMatrixId);
                    const newValue = getValue(resultMatrixId) + getValue(matrixIdA) * getValue(matrixIdB)
                    setValue(resultMatrixId, newValue);
                }
                await playActivationFunction‌Animation(resultMatrixId);
                const newValueAfterActivation = 1 / (1 + Math.exp(-1 * getValue(resultMatrixId)));
                setValue(resultMatrixId, newValueAfterActivation);
            }
        }
    }

    function getColumn(matrix, columnIndex) {
        const result = [];
        for(let i=0;i<matrix.length;i++){
            const row = matrix[i];
             result.push(row[columnIndex]);
        }
        return result;
    }

    function getDataSet(){
        // 从data.js中获取数据集
        return dataSet;
    }

    function putDataToScreen(data,label){
        for(let i = 0; i < data.length; i++){
            const row = data[i];
            for(let j = 0; j< row.length; j++){
                const value = row[j];
                const id = "screen_" + i + "_" + j;
                setValue(id, Boolean(value));
            }

        }
    }

    async function putTrainDataToMatrix(data, labelMatrix){
        let m = 0;
        for(let i = 0; i < data.length; i++){
            const row = data[i];
            for(let j = 0; j< row.length; j++){
                const value = row[j];
                const layer0Id = "layer0_" + m + "_0";
                await playPutTrainDataToMatrix(i,j,layer0Id);
                setValue(layer0Id, value);
                m++;
            }

        }
        for(let i = 0; i < labelMatrix.length; i++){
            const value = labelMatrix[i];
            const labelMatrixId = "label_" + i + "_0";
            setValue(labelMatrixId, value);
        }
    }

    async function outputDeltaFunction‌(outputIdMatrix, labelIdMatrix, outputDeltaIdMatrix){
        for(let i=0;i<outputIdMatrix.length;i++){
            const outputId = outputIdMatrix[i][0];
            const labelId = labelIdMatrix[i][0];
            const outputDeltaId = outputDeltaIdMatrix[i][0];
            const resultValue = getValue(outputId);
            const labelValue = getValue(labelId);
            const outputDeltaValue = 0.2 * (resultValue - labelValue);
            await playOutputDeltaFunction‌Animation(outputId, labelId, outputDeltaId)
            setValue(outputDeltaId, outputDeltaValue);
            await sleep(animationDelay);
        }
    }

    async function backpropagation‌(learnRate, weightIdMatrix, deltaIdMatrix, layerIdMatrix, upperLayerIdMatrix, upperLayerDeltaIdMatrix){
        // 更新上一层到这一层的权重
        for(let i=0;i<weightIdMatrix.length;i++){
            for(let j=0;j<weightIdMatrix[i].length;j++){
                const weightId = weightIdMatrix[i][j];
                const deltaId = deltaIdMatrix[i][0];
                const layerId = layerIdMatrix[i][0];
                const upperLayerId = upperLayerIdMatrix[j][0];
                const weightValue = getValue(weightId);
                const deltaValue = getValue(deltaId);
                const layerValue = getValue(layerId);
                const upperLayerValue = getValue(upperLayerId);
                const newWeightValue = weightValue +  (learnRate * -1) * deltaValue * upperLayerValue * layerValue * (1 - layerValue);
                // if(weightId == "weight0_1_0_0"){
                //     debugger
                    
                // }
                await playBackpropagation‌WeightAnimation(weightId, deltaId, upperLayerId, layerId);
                setValue(weightId, newWeightValue);
            }
        }
        if(!upperLayerDeltaIdMatrix){
            return;
        }
        clearArrow();
        // 输出上一层的神经元的需要修改的量
        for(let i=0;i<upperLayerDeltaIdMatrix.length;i++){
            const upperLayerDeltaId = upperLayerDeltaIdMatrix[i][0];
            setValue(upperLayerDeltaId, 0);
            for(let m=0;m<weightIdMatrix.length;m++){
                const weightId = weightIdMatrix[m][i];
                const deltaId = deltaIdMatrix[m][0];
                const weightValue = getValue(weightId);
                const deltaValue = getValue(deltaId);
                const upperLayerDelta = getValue(upperLayerDeltaId);
                const newUpperLayerDelta = upperLayerDelta + weightValue * deltaValue;
                await playBackpropagation‌LayerAnimation(weightId,deltaId,upperLayerDeltaId);
                setValue(upperLayerDeltaId, newUpperLayerDelta);
            }
        }
        
    }

    function lightUpMaxValue(idMatrix){
        let maxValue = -Infinity;
        let maxId = null;
        for(let i=0;i<idMatrix.length;i++){
            const id = idMatrix[i][0];
            const element = document.getElementById(id);
            element.style.backgroundColor = "white";
            const value = getValue(id);
            if(value > maxValue){
                maxValue = value;
                maxId = id;
            }
            
        }
        const maxElement = document.getElementById(maxId);
        maxElement.style.backgroundColor = "red";
    }

    async function start(){
        await sleep(1000);
        const dataSet = getDataSet();
        // setValue(weight0_1IdMatrix[0][0], 1);
        // for(let i=0;i<1000;i++){
        //     setValue(weight0_1IdMatrix[0][0],getValue(weight0_1IdMatrix[0][0]) + 1);
        // }
        // console.log("weight0_1IdMatrix[0][0]",getValue(weight0_1IdMatrix[0][0]))
        // 训练
        for(let t = 0; t < 2000; t++){
            for(let i = 0; i < dataSet.length; i++){
                const item = dataSet[i];
                putDataToScreen(item.data, item.label);
                // 正向传播
                setProgress("正向推理中")
                await putTrainDataToMatrix(item.data, item.labelMatrix);
                await sigmodMatrixCross(weight0_1IdMatrix, layer0IdMatrix, layer1IdMatrix);
                await sigmodMatrixCross(weight1_2IdMatrix, layer1IdMatrix, layer2IdMatrix);
                await sigmodMatrixCross(weight2_3IdMatrix, layer2IdMatrix, layer3IdMatrix);
                clearArrow();
                // 反向传播
                setProgress("反向传播中")
                await outputDeltaFunction‌(layer3IdMatrix, labelIdMatrix, delta3IdMatrix);
                clearArrow();
                lightUpMaxValue(layer3IdMatrix);
                lightUpMaxValue(labelIdMatrix);
                await backpropagation‌(learnRate, weight2_3IdMatrix, delta3IdMatrix, layer3IdMatrix, layer2IdMatrix, delta2IdMatrix);
                await backpropagation‌(learnRate, weight1_2IdMatrix, delta2IdMatrix, layer2IdMatrix, layer1IdMatrix, delta1IdMatrix);
                await backpropagation‌(learnRate, weight0_1IdMatrix, delta1IdMatrix, layer1IdMatrix, layer0IdMatrix);
                clearArrow();
            }
            // await sleep(animationDelay);
            if(t % 10 == 0){
                console.log("第" + t + "次训练完成", new Date());
                await sleep(animationDelay);
            }
        }
        // 推理
        for(let t = 0; ; t++){
            for(let i = 0; i < dataSet.length; i++){
                const item = dataSet[i];
                
                putDataToScreen(item.data, item.label);
                // 正向传播
                setProgress("正向推理中")
                await putTrainDataToMatrix(item.data, item.labelMatrix);
                await sigmodMatrixCross(weight0_1IdMatrix, layer0IdMatrix, layer1IdMatrix);
                await sigmodMatrixCross(weight1_2IdMatrix, layer1IdMatrix, layer2IdMatrix);
                await sigmodMatrixCross(weight2_3IdMatrix, layer2IdMatrix, layer3IdMatrix);
                clearArrow();
                lightUpMaxValue(layer3IdMatrix);
                lightUpMaxValue(labelIdMatrix);
                await sleep(1000)
                console.log("第" + (t * 10 + i) + "次测试完成", new Date());
            }
        }
        
    }
    
    async function sleep(ms){
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    PetiteVue.createApp(
        {
            layer0IdMatrix : layer0IdMatrix,
            weight0_1IdMatrix : weight0_1IdMatrix,
            layer1IdMatrix : layer1IdMatrix,
            weight1_2IdMatrix : weight1_2IdMatrix,
            layer2IdMatrix : layer2IdMatrix,
            weight2_3IdMatrix : weight2_3IdMatrix,
            layer3IdMatrix : layer3IdMatrix,
            caculatorIdMatrix: caculatorIdMatrix,
            arrowIds: arrowIds,

            maxColumnCount: maxColumnCount,
            maxRowCount: maxRowCount,
        }
    ).mount()

    start();

    
</script>

</html>