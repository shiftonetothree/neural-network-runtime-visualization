<html>

<head>
    <style>
        .screen {
            width: 100px;
            height: 60px;
            width: 60px;
        }

        .screen_table {
            display: flex;
        }

        .matrix_table {
            display: flex;
        }

        .matrix {
            width: 33px;
            height: 18px;
            border: none;
        }

        table {
            border-collapse: collapse;
            border: 2px solid rgb(140 140 140);
            font-family: sans-serif;
            font-size: 0.8rem;
            letter-spacing: 1px;
        }

        caption {
            caption-side: bottom;
            padding: 10px;
            font-weight: bold;
        }

        thead,
        tfoot {
            background-color: rgb(228 240 245);
        }

        th,
        td {
            border: 1px solid rgb(160 160 160);
            /* padding: 8px 10px; */
            /* min-height: 30px; */
        }
        

        td:last-of-type {
            text-align: center;
        }

        tbody>tr:nth-of-type(even) {
            background-color: rgb(237 238 242);
        }

        tfoot th {
            text-align: right;
        }

        tfoot td {
            font-weight: bold;
        }

        .caculator_cell{
            width: 80px;
            max-width: 80px;
            min-width: 80px;
            overflow: hidden;
            height: 15px;
            border: 1px solid rgb(160 160 160);
            text-align: center;
        }

        .arrow{
            background-color: orange;
            position: absolute;
            height: 6px;
            transform-origin: left center;
        }
        .arrow_top{
            position: absolute;
            top: -6px;
            right: -10px;
            clip-path: polygon(0% 0%, 100% 50%, 0% 100%, 30% 50%);
            width: 18px;
            height: 18px;
            background-color: orange;;
            transform-origin: center;
        }
        .matrix_container{
            display: inline-flex;
            align-items: top;
        }
        .matrix_container table{
            display: inline-flex;
        }
        .matrix_container tr{

        }

        .matrix_container td{
            padding: 0;
        }

        .layer{
            background-color: rgba(0, 183, 255, 0.2);
            width: 52px;
        }
        .weight{
            background-color: rgba(0, 183, 255, 0.5);
        }
        .delta{
            background-color: rgba(0, 94, 255, 0.8);
        }
        .label{
            background-color: rgba(0, 183, 255, 0.8);
        }
        #file{
            width: 72px;
        }
        #trainTimes{
            width: 80px;
        }
    </style>
</head>

<body v-scope v-once>
    <table>
        <tr v-for="(caculatorIds, index) in caculatorIdMatrix">
            <td class="caculator_cell">公式{{index+1}}：</td>
            <td v-for="id in caculatorIds" :id="id" class="caculator_cell"></td>
        </tr>
    </table>
    <div class="matrix_container">
        <table class="matrix_table">
            <tr>
                <th :colspan="maxColumnCount"></th>
                <th>输入层</th>
                <th></th>
                <th></th>
            </tr>
            <tr v-for="(id,index) in layer0IdMatrix">
                <td v-if="index == 0" :colspan="maxColumnCount" :rowspan="maxRowCount"></td>
                <td><input :id="id" class="matrix layer" type="text" min="0" max="1" step="0.01" :value="0"></td>
            </tr>
            <tr>
                <th :colspan="maxColumnCount">输入层到隐藏层1的权重</th>
                <th>隐藏层1</th>
                <th>损失</th>
                <th></th>
            </tr>
            <tr v-for="(row,index) in weight0_1IdMatrix">
                <td v-for="cell in row"><input :id="cell" class="matrix weight" type="text" min="0" max="1" step="0.01" :value="0"></td>
                <td><input :id="'layer1_'+index+'_0'" class="matrix layer" type="text" min="0" max="1" step="0.01" :value="0"></td>
                <td><input :id="'delta1_'+index+'_0'" class="matrix delta" type="text" min="0" max="1" step="0.01"></td>
            </tr>
            <tr>
                <th :colspan="maxColumnCount">隐藏层1到隐藏层2的权重</th>
                <th>隐藏层2</th>
                <th>损失</th>
                <th></th>
            </tr>
            <tr v-for="(row,index) in weight1_2IdMatrix">
                <td v-if="index == 0" :colspan="maxColumnCount - row.length" :rowspan="weight1_2IdMatrix.length"></td>
                <td v-for="cell in row"><input :id="cell" class="matrix weight" type="text" min="0" max="1" step="0.01" :value="0"></td>
                <td><input :id="'layer2_'+index+'_0'" class="matrix layer" type="text" min="0" max="1" step="0.01" :value="0"></td>
                <td><input :id="'delta2_'+index+'_0'" class="matrix delta" type="text" min="0" max="1" step="0.01"></td>
            </tr>
            <tr>
                <th :colspan="maxColumnCount">隐藏层2到输出层的权重</th>
                <th>输出层</th>
                <th>损失</th>
                <th>结果</th>
            </tr>
            <tr v-for="(row,index) in weight2_3IdMatrix">
                <td v-if="index == 0" :colspan="maxColumnCount - row.length" :rowspan="weight2_3IdMatrix.length"></td>
                <td v-for="cell in row"><input :id="cell" class="matrix weight" type="text" min="0" max="1" step="0.01" :value="0"></td>
                <td><input :id="'layer3_'+index+'_0'" class="matrix layer" type="text" min="0" max="1" step="0.01" :value="0"></td>
                <td><input :id="'delta3_'+index+'_0'" class="matrix delta" type="text" min="0" max="1" step="0.01"></td>
                <td><input :id="'label_'+index+'_0'" class="matrix label" type="text" min="0" max="1" step="0.01"></td>
            </tr>
        </table>
        <table class="screen_table">
            <tr><td colspan="3">图像输入板：</td></tr>
            <tr v-for="row in screenIdMatrix">
                <td v-for="id in row"><input :id="id" class="screen" type="checkbox"></td>
            </tr>
            <tr><td><label>预测值：</label></td><td colspan="2"><label id="predict"></label></td></tr>
            <tr><td><label>正确率：</label></td><td colspan="2"><label id="accuracy"></label></td></tr>
            <tr><td colspan="3"><button onclick="downloadWeight(event)">下载模型</button></td></tr>
            <tr><td colspan="3"><label for="file">上传模型</label><input id="file" type="file" accept="application/json" onchange="uploadWeight(event)"></td></tr>
            <tr><td colspan="3"><button onclick="clearWeightToZero()">清除模型，从0开始</button></td></tr>
            <tr><td colspan="3"><button onclick="clearWeightToRandom()">清除模型，从随机数开始</button></td></tr>
            <tr><td colspan="3"><label id="progress">停止</label></td></tr>
            <tr>
                <td colspan="2"><label for="trainTimes">次数：</label><input id="trainTimes" type="number" value="2000"></td>
                <td><button onclick="train()">开始训练</button></td>
            </tr>
            <tr>
                <td colspan="2"><button onclick="pauseTrain()">尽快暂停训练</button></td>
                <td><button onclick="pauseTrain()">停止训练</button></td>
            </tr>
            <tr>
                <td><button onclick="playAnimation()">展示动画</button></td>
                <td colspan="2"><button onclick="skipAnimation()">关闭动画极速运算</button></td>
            </tr>
            <tr>
                <td colspan="3"><button onclick="topSpeedAnimation()">以最快的速度播放动画</button></td>
            </tr>
            <tr>
                <td colspan="3"><label>动画运行速度：</label><input id="animationDelay" type="range" min="0" max="1000" step="1" value="999" onchange="changeAnimationDelay(event)"></td>
            </tr>
            <tr><td colspan="3"><button onclick="test()">运行模型</button></td></tr>
        </table>
    </div>
    <div v-for="arrowId in arrowIds" :id="arrowId" class="arrow">
        <div class="arrow_top"></div>
    </div>
</body>
<script src="petite-vue.iife.js"></script>
<script src="initial-weight.js"></script>
<script>

const learnRate = 0.2;
let animationDelay = 1;
let trainTimes = 2000;
let t = 0;
/** 线程锁，只允许单线程运行 */
let readyToRun = true;
function changeAnimationDelay(e){
    animationDelay = 1000 - e.target.value;
}
function playAnimation(){
    animationDelay = 1000;
    setValue("animationDelay", 1000 - animationDelay)
}
function skipAnimation(){
    animationDelay = 0;
    setValue("animationDelay", 1000 - animationDelay)
}
function topSpeedAnimation(){
    animationDelay = 1;
    setValue("animationDelay", 1000 - animationDelay)
}
const dataSet = [
    {
        data: [
            [1,1,1],
            [1,0,1],
            [1,0,1],
            [1,0,1],
            [1,1,1],
        ],
        label: '0',
        labelMatrix: [
            [1],[0],[0],[0],[0],[0],[0],[0],[0],[0]
        ]
    },
    {
        data: [
            [0,1,0],
            [1,1,0],
            [0,1,0],
            [0,1,0],
            [1,1,1],
        ],
        label: '1',
        labelMatrix: [
            [0],[1],[0],[0],[0],[0],[0],[0],[0],[0]
        ]
    },
    {
        data: [
            [1,1,1],
            [0,0,1],
            [1,1,1],
            [1,0,0],
            [1,1,1],
        ],
        label: '2',
        labelMatrix: [
            [0],[0],[1],[0],[0],[0],[0],[0],[0],[0]
        ]
    },
    {
        data: [
            [1,1,1],
            [0,0,1],
            [1,1,1],
            [0,0,1],
            [1,1,1],
        ],
        label: '3',
        labelMatrix: [
            [0],[0],[0],[1],[0],[0],[0],[0],[0],[0]
        ]
    },
    {
        data: [
            [1,0,1],
            [1,0,1],
            [1,1,1],
            [0,0,1],
            [0,0,1],
        ],
        label: '4',
        labelMatrix: [
            [0],[0],[0],[0],[1],[0],[0],[0],[0],[0]
        ]
    },
    {
        data: [
            [1,1,1],
            [1,0,0],
            [1,1,1],
            [0,0,1],
            [1,1,1],
        ],
        label: '5',
        labelMatrix: [
            [0],[0],[0],[0],[0],[1],[0],[0],[0],[0]
        ]
    },
    {
        data: [
            [1,1,1],
            [1,0,0],
            [1,1,1],
            [1,0,1],
            [1,1,1],
        ],
        label: '6',
        labelMatrix: [
            [0],[0],[0],[0],[0],[0],[1],[0],[0],[0]
        ]
    },
    {
        data: [
            [1,1,1],
            [0,0,1],
            [0,0,1],
            [0,0,1],
            [0,0,1],
        ],
        label: '7',
        labelMatrix: [
            [0],[0],[0],[0],[0],[0],[0],[1],[0],[0]
        ]
    },
    {
        data: [
            [1,1,1],
            [1,0,1],
            [1,1,1],
            [1,0,1],
            [1,1,1],
        ],
        label: '8',
        labelMatrix: [
            [0],[0],[0],[0],[0],[0],[0],[0],[1],[0]
        ]
    },
    {
        data: [
            [1,1,1],
            [1,0,1],
            [1,1,1],
            [0,0,1],
            [1,1,1],
        ],
        label: '9',
        labelMatrix: [
            [0],[0],[0],[0],[0],[0],[0],[0],[0],[1]
        ]
    }
];

const screenIdMatrix = [
    ["screen_0_0", "screen_0_1", "screen_0_3"],
    ["screen_1_0", "screen_1_1", "screen_1_3"],
    ["screen_2_0", "screen_2_1", "screen_2_3"],
    ["screen_3_0", "screen_3_1", "screen_3_3"],
    ["screen_4_0", "screen_4_1", "screen_4_3"],
]

const layer0IdMatrix = [
        ["layer0_0_0"],
        ["layer0_1_0"],
        ["layer0_2_0"],
        ["layer0_3_0"],
        ["layer0_4_0"],
        ["layer0_5_0"],
        ["layer0_6_0"],
        ["layer0_7_0"],
        ["layer0_8_0"],
        ["layer0_9_0"],
        ["layer0_10_0"],
        ["layer0_11_0"],
        ["layer0_12_0"],
        ["layer0_13_0"],
        ["layer0_14_0"]
    ]

    const weight0_1IdMatrix = [
        ["weight0_1_0_0", "weight0_1_0_1", "weight0_1_0_2", "weight0_1_0_3", "weight0_1_0_4", "weight0_1_0_5", "weight0_1_0_6", "weight0_1_0_7", "weight0_1_0_8", "weight0_1_0_9", "weight0_1_0_10", "weight0_1_0_11", "weight0_1_0_12", "weight0_1_0_13", "weight0_1_0_14"],
        ["weight0_1_1_0", "weight0_1_1_1", "weight0_1_1_2", "weight0_1_1_3", "weight0_1_1_4", "weight0_1_1_5", "weight0_1_1_6", "weight0_1_1_7", "weight0_1_1_8", "weight0_1_1_9", "weight0_1_1_10", "weight0_1_1_11", "weight0_1_1_12", "weight0_1_1_13", "weight0_1_1_14"],
        ["weight0_1_2_0", "weight0_1_2_1", "weight0_1_2_2", "weight0_1_2_3", "weight0_1_2_4", "weight0_1_2_5", "weight0_1_2_6", "weight0_1_2_7", "weight0_1_2_8", "weight0_1_2_9", "weight0_1_2_10", "weight0_1_2_11", "weight0_1_2_12", "weight0_1_2_13", "weight0_1_2_14"],
        ["weight0_1_3_0", "weight0_1_3_1", "weight0_1_3_2", "weight0_1_3_3", "weight0_1_3_4", "weight0_1_3_5", "weight0_1_3_6", "weight0_1_3_7", "weight0_1_3_8", "weight0_1_3_9", "weight0_1_3_10", "weight0_1_3_11", "weight0_1_3_12", "weight0_1_3_13", "weight0_1_3_14"],
        ["weight0_1_4_0", "weight0_1_4_1", "weight0_1_4_2", "weight0_1_4_3", "weight0_1_4_4", "weight0_1_4_5", "weight0_1_4_6", "weight0_1_4_7", "weight0_1_4_8", "weight0_1_4_9", "weight0_1_4_10", "weight0_1_4_11", "weight0_1_4_12", "weight0_1_4_13", "weight0_1_4_14"],
        ["weight0_1_5_0", "weight0_1_5_1", "weight0_1_5_2", "weight0_1_5_3", "weight0_1_5_4", "weight0_1_5_5", "weight0_1_5_6", "weight0_1_5_7", "weight0_1_5_8", "weight0_1_5_9", "weight0_1_5_10", "weight0_1_5_11", "weight0_1_5_12", "weight0_1_5_13", "weight0_1_5_14"],
        ["weight0_1_6_0", "weight0_1_6_1", "weight0_1_6_2", "weight0_1_6_3", "weight0_1_6_4", "weight0_1_6_5", "weight0_1_6_6", "weight0_1_6_7", "weight0_1_6_8", "weight0_1_6_9", "weight0_1_6_10", "weight0_1_6_11", "weight0_1_6_12", "weight0_1_6_13", "weight0_1_6_14"],
        ["weight0_1_7_0", "weight0_1_7_1", "weight0_1_7_2", "weight0_1_7_3", "weight0_1_7_4", "weight0_1_7_5", "weight0_1_7_6", "weight0_1_7_7", "weight0_1_7_8", "weight0_1_7_9", "weight0_1_7_10", "weight0_1_7_11", "weight0_1_7_12", "weight0_1_7_13", "weight0_1_7_14"],
        ["weight0_1_8_0", "weight0_1_8_1", "weight0_1_8_2", "weight0_1_8_3", "weight0_1_8_4", "weight0_1_8_5", "weight0_1_8_6", "weight0_1_8_7", "weight0_1_8_8", "weight0_1_8_9", "weight0_1_8_10", "weight0_1_8_11", "weight0_1_8_12", "weight0_1_8_13", "weight0_1_8_14"],
        ["weight0_1_9_0", "weight0_1_9_1", "weight0_1_9_2", "weight0_1_9_3", "weight0_1_9_4", "weight0_1_9_5", "weight0_1_9_6", "weight0_1_9_7", "weight0_1_9_8", "weight0_1_9_9", "weight0_1_9_10", "weight0_1_9_11", "weight0_1_9_12", "weight0_1_9_13", "weight0_1_9_14"]
    ]


    const layer1IdMatrix = [
        ["layer1_0_0"],
        ["layer1_1_0"],
        ["layer1_2_0"],
        ["layer1_3_0"],
        ["layer1_4_0"],
        ["layer1_5_0"],
        ["layer1_6_0"],
        ["layer1_7_0"],
        ["layer1_8_0"],
        ["layer1_9_0"]
    ]

    const weight1_2IdMatrix = [
        ["weight1_2_0_0", "weight1_2_0_1", "weight1_2_0_2", "weight1_2_0_3", "weight1_2_0_4", "weight1_2_0_5", "weight1_2_0_6", "weight1_2_0_7", "weight1_2_0_8", "weight1_2_0_9"],
        ["weight1_2_1_0", "weight1_2_1_1", "weight1_2_1_2", "weight1_2_1_3", "weight1_2_1_4", "weight1_2_1_5", "weight1_2_1_6", "weight1_2_1_7", "weight1_2_1_8", "weight1_2_1_9"],
        ["weight1_2_2_0", "weight1_2_2_1", "weight1_2_2_2", "weight1_2_2_3", "weight1_2_2_4", "weight1_2_2_5", "weight1_2_2_6", "weight1_2_2_7", "weight1_2_2_8", "weight1_2_2_9"],
        ["weight1_2_3_0", "weight1_2_3_1", "weight1_2_3_2", "weight1_2_3_3", "weight1_2_3_4", "weight1_2_3_5", "weight1_2_3_6", "weight1_2_3_7", "weight1_2_3_8", "weight1_2_3_9"],
        ["weight1_2_4_0", "weight1_2_4_1", "weight1_2_4_2", "weight1_2_4_3", "weight1_2_4_4", "weight1_2_4_5", "weight1_2_4_6", "weight1_2_4_7", "weight1_2_4_8", "weight1_2_4_9"],
        ["weight1_2_5_0", "weight1_2_5_1", "weight1_2_5_2", "weight1_2_5_3", "weight1_2_5_4", "weight1_2_5_5", "weight1_2_5_6", "weight1_2_5_7", "weight1_2_5_8", "weight1_2_5_9"],
        ["weight1_2_6_0", "weight1_2_6_1", "weight1_2_6_2", "weight1_2_6_3", "weight1_2_6_4", "weight1_2_6_5", "weight1_2_6_6", "weight1_2_6_7", "weight1_2_6_8", "weight1_2_6_9"],
        ["weight1_2_7_0", "weight1_2_7_1", "weight1_2_7_2", "weight1_2_7_3", "weight1_2_7_4", "weight1_2_7_5", "weight1_2_7_6", "weight1_2_7_7", "weight1_2_7_8", "weight1_2_7_9"],
        ["weight1_2_8_0", "weight1_2_8_1", "weight1_2_8_2", "weight1_2_8_3", "weight1_2_8 4", "weight1_2_8_5", "weight1_2_8_6", "weight1_2_8_7", "weight1_2_8_8", "weight1_2_8_9"],
        ["weight1_2_9_0", "weight1_2_9_1", "weight1_2_9_2", "weight1_2_9_3", "weight1_2_9 4", "weight1_2_9_5", "weight1_2_9_6", "weight1_2_9_7", "weight1_2_9_8", "weight1_2_9_9"]
    ]

    const layer2IdMatrix = [
        ["layer2_0_0"],
        ["layer2_1_0"],
        ["layer2_2_0"],
        ["layer2_3_0"],
        ["layer2_4_0"],
        ["layer2_5_0"],
        ["layer2_6_0"],
        ["layer2_7_0"],
        ["layer2_8_0"],
        ["layer2_9_0"]
    ]

    const weight2_3IdMatrix = [
        ["weight2_3_0_0", "weight2_3_0_1", "weight2_3_0_2", "weight2_3_0_3", "weight2_3_0_4", "weight2_3_0_5", "weight2_3_0_6", "weight2_3_0_7", "weight2_3_0_8", "weight2_3_0_9"],
        ["weight2_3_1_0", "weight2_3_1_1", "weight2_3_1_2", "weight2_3_1_3", "weight2_3_1_4", "weight2_3_1_5", "weight2_3_1_6", "weight2_3_1_7", "weight2_3_1_8", "weight2_3_1_9"],
        ["weight2_3_2_0", "weight2_3_2_1", "weight2_3_2_2", "weight2_3_2_3", "weight2_3_2_4", "weight2_3_2_5", "weight2_3_2_6", "weight2_3_2_7", "weight2_3_2_8", "weight2_3_2_9"],
        ["weight2_3_3_0", "weight2_3_3_1", "weight2_3_3_2", "weight2_3_3_3", "weight2_3_3_4", "weight2_3_3_5", "weight2_3_3_6", "weight2_3_3_7", "weight2_3_3_8", "weight2_3_3_9"],
        ["weight2_3_4_0", "weight2_3_4_1", "weight2_3_4_2", "weight2_3_4_3", "weight2_3_4_4", "weight2_3_4_5", "weight2_3_4_6", "weight2_3_4_7", "weight2_3_4_8", "weight2_3_4_9"],
        ["weight2_3_5_0", "weight2_3_5_1", "weight2_3_5_2", "weight2_3_5_3", "weight2_3_5_4", "weight2_3_5_5", "weight2_3_5_6", "weight2_3_5_7", "weight2_3_5_8", "weight2_3_5_9"],
        ["weight2_3_6_0", "weight2_3_6_1", "weight2_3_6_2", "weight2_3_6_3", "weight2_3_6_4", "weight2_3_6_5", "weight2_3_6_6", "weight2_3_6_7", "weight2_3_6_8", "weight2_3_6_9"],
        ["weight2_3_7_0", "weight2_3_7_1", "weight2_3_7_2", "weight2_3_7_3", "weight2_3_7_4", "weight2_3_7_5", "weight2_3_7_6", "weight2_3_7_7", "weight2_3_7_8", "weight2_3_7_9"],
        ["weight2_3_8_0", "weight2_3_8_1", "weight2_3_8_2", "weight2_3_8_3", "weight2_3_8_4", "weight2_3_8_5", "weight2_3_8_6", "weight2_3_8_7", "weight2_3_8_8", "weight2_3_8_9"],
        ["weight2_3_9_0", "weight2_3_9_1", "weight2_3_9_2", "weight2_3_9_3", "weight2_3_9 4", "weight2_3_9_5", "weight2_3_9_6", "weight2_3_9_7", "weight2_3_9_8", "weight2_3_9_9"]
    ]

    const layer3IdMatrix = [
        ["layer3_0_0"],
        ["layer3_1_0"],
        ["layer3_2_0"],
        ["layer3_3_0"],
        ["layer3_4_0"],
        ["layer3_5_0"],
        ["layer3_6_0"],
        ["layer3_7_0"],
        ["layer3_8_0"],
        ["layer3_9_0"]
    ]

    const labelIdMatrix = [
        ["label_0_0"],
        ["label_1_0"],
        ["label_2_0"],
        ["label_3_0"],
        ["label_4_0"],
        ["label_5_0"],
        ["label_6_0"],
        ["label_7_0"],
        ["label_8_0"],
        ["label_9_0"]
    ]

    const delta1IdMatrix = [
        ["delta1_0_0"],
        ["delta1_1_0"],
        ["delta1_2_0"],
        ["delta1_3_0"],
        ["delta1_4_0"],
        ["delta1_5_0"],
        ["delta1_6_0"],
        ["delta1_7_0"],
        ["delta1_8_0"],
        ["delta1_9_0"]
    ]

    const delta2IdMatrix = [
        ["delta2_0_0"],
        ["delta2_1_0"],
        ["delta2_2_0"],
        ["delta2_3_0"],
        ["delta2_4_0"],
        ["delta2_5_0"],
        ["delta2_6_0"],
        ["delta2_7_0"],
        ["delta2_8_0"],
        ["delta2_9_0"]
    ]

    const delta3IdMatrix = [
        ["delta3_0_0"],
        ["delta3_1_0"],
        ["delta3_2_0"],
        ["delta3_3_0"],
        ["delta3_4_0"],
        ["delta3_5_0"],
        ["delta3_6_0"],
        ["delta3_7_0"],
        ["delta3_8_0"],
        ["delta3_9_0"]
    ]

    const caculatorIdMatrix = [
        ["caculator0_0", "caculator0_1", "caculator0_2", "caculator0_3", "caculator0_4", "caculator0_5", "caculator0_6", "caculator0_7", "caculator0_8", "caculator0_9", "caculator0_10", "caculator0_11"],
        ["caculator1_0", "caculator1_1", "caculator1_2", "caculator1_3", "caculator1_4", "caculator1_5", "caculator1_6", "caculator1_7", "caculator1_8", "caculator1_9", "caculator1_10", "caculator1_11"],
        ["caculator2_0", "caculator2_1", "caculator2_2", "caculator2_3", "caculator2_4", "caculator2_5", "caculator2_6", "caculator2_7", "caculator2_8", "caculator2_9", "caculator2_10", "caculator2_11"],
        ["caculator3_0", "caculator3_1", "caculator3_2", "caculator3_3", "caculator3_4", "caculator3_5", "caculator3_6", "caculator3_7", "caculator3_8", "caculator3_9", "caculator3_10", "caculator3_11"],
        ["caculator4_0", "caculator4_1", "caculator4_2", "caculator4_3", "caculator4_4", "caculator4_5", "caculator4_6", "caculator4_7", "caculator4_8", "caculator4_9", "caculator4_10", "caculator4_11"],
    ]

    const arrowIds = [
        "arrow0",
        "arrow1",
        "arrow2",
        "arrow3",
        "arrow4",
        "arrow5",
        "arrow6",
        "arrow7",
    ]
    const maxColumnCount = Math.max(
        weight0_1IdMatrix[0].length, weight1_2IdMatrix[0].length, weight2_3IdMatrix[0].length
    );
    const maxRowCount = Math.max(
        layer0IdMatrix.length, layer1IdMatrix.length, layer2IdMatrix.length, layer3IdMatrix.length
    );

    function getValue(id) {
        // console.log("getValue id", id)
        // if (id == null) {
        //     debugger;
        // }
        const element = document.getElementById(id);
        if(element.type == "checkbox"){
            return element.checked;
        }else{
            return parseFloat(element.value);
        }
        
    }
    function refreshWeightBackground(weightIdMatrix){
        for (let i=0;i<weightIdMatrix.length;i++){
            const row = weightIdMatrix[i];
            for(let j=0;j<row.length;j++){
                const weightId = row[j];
                setMatirxBackgroundByValue(weightId,getValue(weightId))
            }
        }
    }
    function setMatirxBackgroundByValue(id, value){
        const element = document.getElementById(id);
        if(element.className.indexOf("matrix") >= 0 && element.className.indexOf("weight") >= 0){
            const gray = (-value - 10) * 255 / 20 + 255;
            element.style.backgroundColor = "rgba("+ gray + "," + gray + "," + gray + ")";
        }
    }
    function setValue(id, value) {
        // if(id == "weight0_1_0_0"){
        //     debugger
        // }
        // console.log("setValue id", id)
        const element = document.getElementById(id);
        if(animationDelay != 0){
            setMatirxBackgroundByValue(id, value)
        }
        if (element.className.indexOf("caculator_cell")>=0){
            element.innerText = value;
        }else if(element.type == "checkbox"){
            element.checked = value;
            return;
        }else{
            element.value = value;
            return;
        }
        
    }

    function setCaculator(row, cells){
        for(let i = 0; i < cells.length; i++){
            const cell = cells[i];
            const id = "caculator" + row + "_" + (i);
            setValue(id, cell);
        }
    }

    function setProgress(progress){
        document.getElementById("progress").innerHTML = progress;
    }

    function getAbsolutePosition(element) {
        let x = 0, y = 0;
        let current = element;
        while (current) {
            x += current.offsetLeft;
            y += current.offsetTop;
            current = current.offsetParent;
        }
        return { x: x + 10, y: y + 10 };
    }

    /** 绘制一个从一个元素到另一个元素的直线 */
    function drawArrow(arrowId, color ,elementIdA,elementIdB){
        const elementA = document.getElementById(elementIdA);
        const elementB = document.getElementById(elementIdB);
        const {x: x1, y: y1} = getAbsolutePosition(elementA);
        const {x: x2, y: y2} = getAbsolutePosition(elementB);
        const arrow = document.getElementById(arrowId);
        arrow.style.width = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)) - 10 + "px";
        arrow.style.left = x1 + "px";
        arrow.style.top = y1 + "px";
        arrow.style.transform = "rotate(" + Math.atan2((y2 - y1), x2 - x1) + "rad)";
        arrow.style.backgroundColor = color;
        arrow.style.display = "block";
        arrow.children.item(0).style.backgroundColor = color;
    }

    function clearArrow(arrowId){
        for(let i = 0;i<arrowIds.length;i++){
            const arrowId = arrowIds[i];
            const arrow = document.getElementById(arrowId);
            arrow.style.display = "none";
        }
    }


    async function playMatrixCrossStepAnimation(matrixIdA,matrixIdB,resultMatrixId){
        if(animationDelay == 0){
            return;
        }
        const result = getValue(resultMatrixId) + getValue(matrixIdA) * getValue(matrixIdB)
        setCaculator(0,[getValue(resultMatrixId),"+",getValue(matrixIdA),"*",getValue(matrixIdB),"=",result]);
        drawArrow(arrowIds[0],"orange",resultMatrixId, caculatorIdMatrix[0][0]);
        drawArrow(arrowIds[1],"orange",matrixIdA, caculatorIdMatrix[0][2]);
        drawArrow(arrowIds[2],"orange",matrixIdB, caculatorIdMatrix[0][4]);
        drawArrow(arrowIds[3],"red",caculatorIdMatrix[0][6], resultMatrixId);
        await sleep(animationDelay);
    }

    async function playActivationFunction‌Animation(resultMatrixId){
        if(animationDelay == 0){
            return;
        }
        const result = 1 / (1 + Math.exp(getValue(resultMatrixId)))
        setCaculator(1,["1 / (1 + " , "Math.exp(",getValue(resultMatrixId),") =",result]);
        drawArrow(arrowIds[1],"orange", resultMatrixId, caculatorIdMatrix[1][2]);
        drawArrow(arrowIds[2],"red",caculatorIdMatrix[1][4], resultMatrixId)
        await sleep(animationDelay * 10);
    }

    async function playOutputDeltaFunction‌Animation(outputId, labelId, outputDeltaId){
        if(animationDelay == 0){
            return;
        }
        const resultValue = getValue(outputId);
        const labelValue = getValue(labelId);
        const outputDeltaValue = 0.2 * (resultValue - labelValue);
        setCaculator(2,["0.2 * (",resultValue,"-",labelValue,") =",outputDeltaValue]);
        drawArrow(arrowIds[5],"orange",outputId, caculatorIdMatrix[2][1]);
        drawArrow(arrowIds[6],"orange",labelId, caculatorIdMatrix[2][3]);
        drawArrow(arrowIds[7],"red",caculatorIdMatrix[2][5], outputDeltaId);
        await sleep(animationDelay);
    }

    async function playBackpropagation‌WeightAnimation(weightId, deltaId, upperLayerId,layerId){
        if(animationDelay == 0){
            return;
        }
        const weightValue = getValue(weightId);
        const deltaValue = getValue(deltaId);
        const layerValue = getValue(layerId);
        const upperLayerValue = getValue(upperLayerId);
        const newWeightValue = weightValue +  (learnRate * -1) * deltaValue * upperLayerValue * layerValue * (1 - layerValue);
        setCaculator(3,[weightValue,"+ ("+learnRate," * -1) *",deltaValue,"*",upperLayerValue,"*",layerValue,"* (1 -",layerValue,") =", newWeightValue]);
        drawArrow(arrowIds[0],"orange",weightId, caculatorIdMatrix[3][0]);
        drawArrow(arrowIds[1],"orange",deltaId, caculatorIdMatrix[3][3]);
        drawArrow(arrowIds[2],"orange",upperLayerId, caculatorIdMatrix[3][5]);
        drawArrow(arrowIds[3],"orange",layerId, caculatorIdMatrix[3][7]);
        drawArrow(arrowIds[4],"orange",layerId, caculatorIdMatrix[3][9]);
        drawArrow(arrowIds[5],"red",caculatorIdMatrix[3][11], weightId);
        await sleep(animationDelay);
    }

    async function playBackpropagation‌LayerAnimation(weightId,deltaId,upperLayerDeltaId){
        if(animationDelay == 0){
            return;
        }
        const weightValue = getValue(weightId);
        const deltaValue = getValue(deltaId);
        const upperLayerDelta = getValue(upperLayerDeltaId);
        const newUpperLayerDelta = upperLayerDelta + weightValue * deltaValue;
        setCaculator(4,[upperLayerDelta,"+",weightValue,"*",deltaValue,"=",newUpperLayerDelta]);
        drawArrow(arrowIds[0],"orange", upperLayerDeltaId, caculatorIdMatrix[4][0]);
        drawArrow(arrowIds[1],"orange", weightId, caculatorIdMatrix[4][2]);
        drawArrow(arrowIds[2],"orange", deltaId, caculatorIdMatrix[4][4]);
        drawArrow(arrowIds[3],"red", caculatorIdMatrix[4][6], upperLayerDeltaId);
        await sleep(animationDelay);
    }

    async function playPredictValueAnimation(layer3Id){
        if(animationDelay == 0){
            return;
        }
        drawArrow(arrowIds[0],"red", layer3Id, "predict");
        await sleep(animationDelay * 100);
    }

    async function playPutTrainDataToMatrix(layerId, screenId){
        if(animationDelay == 0){
            return;
        }
        drawArrow(arrowIds[0],"red", screenId, layerId);
        await sleep(animationDelay)
    }

    
    /** 激活函数和矩阵乘法的复合Sigmod(AB) */
    async function sigmodMatrixCross(matrixIdsA, matrixIdsB, resultMatrixIds) {
        for (let i = 0; i < matrixIdsA.length; i++) {
            // 左取行
            const matrixIdsARow = matrixIdsA[i];
            for(let j=0;j< matrixIdsB[0].length;j++){
                // 右取列
                const matrixIdsBColumn = getColumn(matrixIdsB, j);
                const resultMatrixId = resultMatrixIds[i][j];
                // if(resultMatrixId == "layer3_0_0"){
                //     debugger
                // }
                setValue(resultMatrixId, 0);
                for(let m = 0; m < matrixIdsARow.length; m++){
                    // 相乘再相加
                    const matrixIdA = matrixIdsARow[m];
                    const matrixIdB = matrixIdsBColumn[m];
                    await playMatrixCrossStepAnimation(matrixIdA, matrixIdB, resultMatrixId);
                    const newValue = getValue(resultMatrixId) + getValue(matrixIdA) * getValue(matrixIdB)
                    setValue(resultMatrixId, newValue);
                }
                clearArrow();
                await playActivationFunction‌Animation(resultMatrixId);
                const newValueAfterActivation = 1 / (1 + Math.exp(-1 * getValue(resultMatrixId)));
                setValue(resultMatrixId, newValueAfterActivation);
                clearArrow();
            }
        }
    }

    function getColumn(matrix, columnIndex) {
        const result = [];
        for(let i=0;i<matrix.length;i++){
            const row = matrix[i];
             result.push(row[columnIndex]);
        }
        return result;
    }

    function getDataSet(){
        // 从data.js中获取数据集
        return dataSet;
    }

    function putDataToScreen(data,label,screenIdMatrix){
        for(let i = 0; i < data.length; i++){
            const row = data[i];
            for(let j = 0; j< row.length; j++){
                const value = row[j];
                const id = screenIdMatrix[i][j];
                setValue(id, Boolean(value));
            }
        }
    }

    async function getDataFromScreen(layer0IdMatrix, screenIdMatrix){
        let m = 0;
        const data = [];
        for(let i = 0; i < screenIdMatrix.length; i++){
            const row = screenIdMatrix[i];
            for(let j = 0; j< row.length; j++){
                const id = screenIdMatrix[i][j];
                const layer0Id = layer0IdMatrix[m][0];
                const booleanValue = getValue(id);
                const value = booleanValue ? 1 : 0;
                await playPutTrainDataToMatrix(layer0Id, screenIdMatrix[i][j]);
                setValue(layer0Id, value);
                m++;
            }
        }
    }

    async function putTrainDataToMatrix(data, labelMatrix, labelIdMatrix, layer0IdMatrix, screenIdMatrix){
        let m = 0;
        for(let i = 0; i < data.length; i++){
            const row = data[i];
            for(let j = 0; j< row.length; j++){
                const value = row[j];
                const layer0Id = layer0IdMatrix[m][0];
                await playPutTrainDataToMatrix(layer0Id, screenIdMatrix[i][j]);
                setValue(layer0Id, value);
                m++;
            }

        }
        for(let i = 0; i < labelMatrix.length; i++){
            const value = labelMatrix[i];
            const labelMatrixId = labelIdMatrix[i];
            setValue(labelMatrixId, value);
        }
    }

    

    async function outputDeltaFunction‌(outputIdMatrix, labelIdMatrix, outputDeltaIdMatrix){
        for(let i=0;i<outputIdMatrix.length;i++){
            const outputId = outputIdMatrix[i][0];
            const labelId = labelIdMatrix[i][0];
            const outputDeltaId = outputDeltaIdMatrix[i][0];
            const resultValue = getValue(outputId);
            const labelValue = getValue(labelId);
            const outputDeltaValue = 0.2 * (resultValue - labelValue);
            await playOutputDeltaFunction‌Animation(outputId, labelId, outputDeltaId)
            setValue(outputDeltaId, outputDeltaValue);
            await sleep(animationDelay);
        }
    }

    async function backpropagation‌(learnRate, weightIdMatrix, deltaIdMatrix, layerIdMatrix, upperLayerIdMatrix, upperLayerDeltaIdMatrix){
        // 更新上一层到这一层的权重
        for(let i=0;i<weightIdMatrix.length;i++){
            for(let j=0;j<weightIdMatrix[i].length;j++){
                const weightId = weightIdMatrix[i][j];
                const deltaId = deltaIdMatrix[i][0];
                const layerId = layerIdMatrix[i][0];
                const upperLayerId = upperLayerIdMatrix[j][0];
                const weightValue = getValue(weightId);
                const deltaValue = getValue(deltaId);
                const layerValue = getValue(layerId);
                const upperLayerValue = getValue(upperLayerId);
                const newWeightValue = weightValue +  (learnRate * -1) * deltaValue * upperLayerValue * layerValue * (1 - layerValue);
                // if(weightId == "weight0_1_0_0"){
                //     debugge
                    
                // }
                await playBackpropagation‌WeightAnimation(weightId, deltaId, upperLayerId, layerId);
                setValue(weightId, newWeightValue);
            }
        }
        if(!upperLayerDeltaIdMatrix){
            return;
        }
        clearArrow();
        // 输出上一层的神经元的需要修改的量
        for(let i=0;i<upperLayerDeltaIdMatrix.length;i++){
            const upperLayerDeltaId = upperLayerDeltaIdMatrix[i][0];
            setValue(upperLayerDeltaId, 0);
            for(let m=0;m<weightIdMatrix.length;m++){
                const weightId = weightIdMatrix[m][i];
                const deltaId = deltaIdMatrix[m][0];
                const weightValue = getValue(weightId);
                const deltaValue = getValue(deltaId);
                const upperLayerDelta = getValue(upperLayerDeltaId);
                const newUpperLayerDelta = upperLayerDelta + weightValue * deltaValue;
                await playBackpropagation‌LayerAnimation(weightId,deltaId,upperLayerDeltaId);
                setValue(upperLayerDeltaId, newUpperLayerDelta);
            }
        }
        
    }

    function lightUpMaxValue(idMatrix){
        let maxValue = -Infinity;
        let maxId = null;
        for(let i=0;i<idMatrix.length;i++){
            const id = idMatrix[i][0];
            const element = document.getElementById(id);
            element.style.backgroundColor = "white";
            const value = getValue(id);
            if(value > maxValue){
                maxValue = value;
                maxId = id;
            }
            
        }
        const maxElement = document.getElementById(maxId);
        if(maxElement){
            maxElement.style.backgroundColor = "orange";
        } 
        
    }

    async function getPredictValue(){
        let maxValue = -Infinity;
        let maxId = null;
        let maxIndex = -1;
        for(let i=0;i<layer3IdMatrix.length;i++){
            const id = layer3IdMatrix[i][0];
            const element = document.getElementById(id);
            element.style.backgroundColor = "white";
            const value = getValue(id);
            if(value > maxValue){
                maxValue = value;
                maxId = id;
                maxIndex = i;
            }
        }
        document.getElementById("predict").innerHTML = maxIndex;
        const maxElement = document.getElementById(maxId);
        maxElement.style.backgroundColor = "orange";
        await playPredictValueAnimation(maxId);
        return maxIndex;
    }

    function getMatrixData(idMatrix){
        const matrix = [];
        for(let i=0;i<idMatrix.length;i++){
            const row = idMatrix[i];
            const rowData = [];
            for(let j=0;j<row.length;j++){
                const id = row[j];
                const value = getValue(id);
                rowData.push(value);
            }
            matrix.push(rowData);
        }
        return matrix
    }

    function setMatrixData(idMatrix, data){
        for(let i=0;i<idMatrix.length;i++){
            const row = idMatrix[i];
            for(let j=0;j<row.length;j++){
                const id = row[j];
                const value = data[i][j];
                setValue(id, value);
            }
        }
    }

    function setMatrixToRandomNumber(idMatrix){
        for(let i=0;i<idMatrix.length;i++){
            const row = idMatrix[i];
            for(let j=0;j<row.length;j++){
                const id = row[j];
                const value = Math.random() - 0.5;
                setValue(id, value);
            }
        }
        refreshWeightBackground(weight0_1IdMatrix)
    }

    function setMatrixToZero(idMatrix){
        for(let i=0;i<idMatrix.length;i++){
            const row = idMatrix[i];
            for(let j=0;j<row.length;j++){
                const id = row[j];
                const value = 0;
                setValue(id, value);
            }
        }
        refreshWeightBackground(weight0_1IdMatrix)
    }

    function downloadPreTrainedModel(){
        const weight0_1 = getMatrixData(weight0_1IdMatrix);
        const weight1_2 = getMatrixData(weight1_2IdMatrix);
        const weight2_3 = getMatrixData(weight2_3IdMatrix);
        downloadFile(JSON.stringify({
            weight0_1,
            weight1_2,
            weight2_3
        })); 
    }

    function clearWeightToRandom() {
        setMatrixToRandomNumber(weight0_1IdMatrix)
        setMatrixToRandomNumber(weight1_2IdMatrix)
        setMatrixToRandomNumber(weight2_3IdMatrix)
    }

    function clearWeightToZero() {
        setMatrixToRandomNumber(weight0_1IdMatrix)
        setMatrixToRandomNumber(weight1_2IdMatrix)
        setMatrixToRandomNumber(weight2_3IdMatrix)
    }

    function downloadWeight(){
        const weight0_1 = getMatrixData(weight0_1IdMatrix);
        const weight1_2 = getMatrixData(weight1_2IdMatrix);
        const weight2_3 = getMatrixData(weight2_3IdMatrix);
        downloadFile(JSON.stringify({
            weight0_1,
            weight1_2,
            weight2_3
        })); 
    }

    async function uploadWeight(event){
        const files = event.target.files;
        if(files.length == 0){
            return;
        }
        const file = files[0];
        event.target.value = ""; // 清空文件选择框
        const reader = new FileReader(); // 创建读取器
        return new Promise((resolve, reject)=>{

        
            reader.onload = (e) => {
                const content = e.target.result;
                const weight = JSON.parse(content);
                try{
                    loadWeight(weight);
                    confirm("模型加载成功");
                }catch(error){
                    alert("模型加载失败")
                    reject("文件格式错误")
                }
            };
            reader.onerror = reject; // 错误处理
            reader.readAsText(file); // 读取为文本
        });
    }

    function loadWeight(weight){
        const {
            weight0_1,
            weight1_2,
            weight2_3
        } = weight;
        setMatrixData(weight0_1IdMatrix, weight0_1);
        setMatrixData(weight1_2IdMatrix, weight1_2);
        setMatrixData(weight2_3IdMatrix, weight2_3);
    }

    function downloadFile(text) {
        const blob = new Blob([text], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "weight.json"; // 设置文件名
        a.click();
        URL.revokeObjectURL(url); // 释放内存
    }

    async function train(){
        trainTimes = getValue("trainTimes");
        if(readyToRun == false){
            alert("已经正在运行");
            return;
        }
        readyToRun = false;
        const dataSet = getDataSet();
        // setValue(weight0_1IdMatrix[0][0], 1);
        // for(let i=0;i<1000;i++){
        //     setValue(weight0_1IdMatrix[0][0],getValue(weight0_1IdMatrix[0][0]) + 1);
        // }
        // console.log("weight0_1IdMatrix[0][0]",getValue(weight0_1IdMatrix[0][0]))
        // 训练
        for(; t < trainTimes; t++){
            if(readyToRun){
                alert("已暂停训练")
                break;
            }
            let accurate = 0;
            for(let i = 0; i < dataSet.length; i++){
                if(readyToRun){
                    break;
                }
                const item = dataSet[i];
                putDataToScreen(item.data, item.label, screenIdMatrix);
                // 正向传播
                setProgress("训练进度"+t+"/"+trainTimes+"，正向推理中")
                await putTrainDataToMatrix(item.data, item.labelMatrix, labelIdMatrix, layer0IdMatrix, screenIdMatrix);
                await sigmodMatrixCross(weight0_1IdMatrix, layer0IdMatrix, layer1IdMatrix);
                await sigmodMatrixCross(weight1_2IdMatrix, layer1IdMatrix, layer2IdMatrix);
                await sigmodMatrixCross(weight2_3IdMatrix, layer2IdMatrix, layer3IdMatrix);
                clearArrow();
                // 反向传播
                setProgress("训练进度"+t+"/"+trainTimes+"，反向传播中")
                await outputDeltaFunction‌(layer3IdMatrix, labelIdMatrix, delta3IdMatrix);
                clearArrow();
                const predictValue = await getPredictValue();
                if(String(predictValue) == item.label){
                    accurate++;
                }
                lightUpMaxValue(labelIdMatrix);
                clearArrow();
                await backpropagation‌(learnRate, weight2_3IdMatrix, delta3IdMatrix, layer3IdMatrix, layer2IdMatrix, delta2IdMatrix);
                await backpropagation‌(learnRate, weight1_2IdMatrix, delta2IdMatrix, layer2IdMatrix, layer1IdMatrix, delta1IdMatrix);
                await backpropagation‌(learnRate, weight0_1IdMatrix, delta1IdMatrix, layer1IdMatrix, layer0IdMatrix);
                clearArrow();
            }
            document.getElementById("accuracy").innerHTML = (accurate * 100 / dataSet.length ).toFixed(2)+"%";
            // await sleep(animationDelay);
            if(t % 10 == 0){
                console.log("第" + t + "次训练完成", new Date());
                if(animationDelay == 0){
                    refreshWeightBackground(weight0_1IdMatrix);
                    refreshWeightBackground(weight1_2IdMatrix);
                    refreshWeightBackground(weight2_3IdMatrix);
                }
                await sleep(10);
            }
        }
        readyToRun = true;
        t = 0;
        setProgress("停止")
    }

    async function pauseTrain(){
        readyToRun = true;
        alert("正在暂停训练，请稍等");
    }

    async function stopTrain(){
        readyToRun = true;
        t = 0;
        alert("正在暂停训练，请稍等");
    }

    async function test(){
        if(!readyToRun){
            alert("已经在运行，请等待结果");
            return;
        }
        readyToRun = false;
        clearArrow();
        // 正向传播
        setProgress("测试中，正向推理中")
        await getDataFromScreen(layer0IdMatrix,screenIdMatrix);
        await sigmodMatrixCross(weight0_1IdMatrix, layer0IdMatrix, layer1IdMatrix);
        await sigmodMatrixCross(weight1_2IdMatrix, layer1IdMatrix, layer2IdMatrix);
        await sigmodMatrixCross(weight2_3IdMatrix, layer2IdMatrix, layer3IdMatrix);
        clearArrow();
        const predictValue = await getPredictValue();
        lightUpMaxValue(labelIdMatrix);
        setProgress("运行结束，请查看预测结果")
        confirm("预测结果是：" + predictValue)
        readyToRun = true;
    }
    
    async function sleep(ms){
        if(ms == 0){
            return;
        }
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    PetiteVue.createApp(
        {
            layer0IdMatrix : layer0IdMatrix,
            weight0_1IdMatrix : weight0_1IdMatrix,
            layer1IdMatrix : layer1IdMatrix,
            weight1_2IdMatrix : weight1_2IdMatrix,
            layer2IdMatrix : layer2IdMatrix,
            weight2_3IdMatrix : weight2_3IdMatrix,
            layer3IdMatrix : layer3IdMatrix,
            caculatorIdMatrix: caculatorIdMatrix,
            arrowIds: arrowIds,

            maxColumnCount: maxColumnCount,
            maxRowCount: maxRowCount,
        }
    ).mount()

    async function loadInitialWeight(){
        await sleep(1000);
        loadWeight(initialWeight);
    }

    loadInitialWeight();

    
</script>

</html>